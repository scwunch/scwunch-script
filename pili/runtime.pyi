from collections import deque
from fractions import Fraction
from typing import overload, TypeVar, Generic
from pili.interpreter import Block

FlexiPatt = ParamSet | Parameter | Matcher | str
PyFunction = type(lambda : None)

class OptionCatalog:
    """
    An OptionCatalog object has is created by deduplicating the options from a sequence of Traits, and categorizing them
    into a list of options and a hash-map of options.  The OptionCatalog is responsible for selecting options from Args.
    """
    op_list: list[Option]
    op_map: dict[Args, Option]
    # noinspection PyDefaultArgument
    def __init__(self, options: dict[FlexiPatt, opt_resolution] = {}, *traits: Trait): ...
    def assign_option(self, pattern: FlexiPatt | Option, resolution: opt_resolution = None, *, no_clobber=False) -> Option: ...
    def remove_option(self, pattern: FlexiPatt): ...
    def select_and_bind(self, key: Args) -> tuple[Option, dict[str, Record]] | tuple[None, None]: ...
    def select_by_pattern(self, patt, default=None, ascend_env=False) -> Option | None: ...

class Record:
    name: str | None
    table: Table
    data: list[Record]
    key: Record
    index: int | None
    truthy: bool = True
    mro: tuple[Trait, ...]
    value: any
    def __init__(self, table, *data_tuple: Record, **data_dict: Record): ...
    def get(self, name: str, *default, search_table_frame_too=False) -> Record: ...
    # def get_by_index(self, index: int) -> Record: ...
    def set(self, name: str, value: Record): ...
    # def set_by_index(self, index: int, value: Record): ...
    @overload
    def call(self, args: Args, *, safe_call=False) -> Record: ...
    @overload
    def call(self, *args: Record, safe_call=False) -> Record: ...
    # def __call__(self, args: Args): ...
    # I should not make Records python callable... that's just confusing
    def select(self, args: Args) -> tuple[Option | None, dict | None]: ...
    def hashable(self) -> bool: ...
    def to_string(self) -> PyValue[str]: ...
    def __index__(self) -> int: ...


T = TypeVar('T', None, bool, int, Fraction, float, str, tuple, frozenset, set, list)
class PyValue(Record, Generic[T]):
    value: T
    def __init__(self, table: Table, value: T): ...

A = TypeVar('A')
class PyObj(Record, Generic[A]):
    obj: any
    def __init__(self, obj): ...

def py_value(value: T) -> PyValue: ...

class Range(Record):
    data: list[PyValue[int]]
    slice: slice | None
    def __init__(self, *args: PyValue): ...
    def __iter__(self): ...

class Function(Record, OptionCatalog):
    # slot_dict: dict[str, Record]
    # formula_dict: dict[str, Function]
    # setter_dict: dict[str, Function]
    frame: Frame | None
    uninitialized: bool
    def __init__(self,
                 options: dict[FlexiPatt, opt_resolution] = None,
                 *fields: Field,
                 name: str = None,
                 table_name: str = 'Function',
                 traits: tuple[Trait, ...] = (),
                 frame: Frame = None,
                 uninitialized=False): ...
    def update_field(self, field: Field): ...
    def get(self, name: str, *default, search_table_frame_too=False) -> Record: ...
    def set(self, name: str, value: Record): ...
    def select(self, args): ...
    # def add_option(self, pattern: FlexiPatt, resolution: opt_resolution = None) -> Option: ...
    # def assign_option(self, pattern: FlexiPatt, resolution: opt_resolution = None) -> Option: ...

class Trait(Function):
    options: list[Option]
    # hashed_options: dict[tuple[Record, ...], Option]
    # field_ids: dict[str, int]
    fields: list[Field]
    # trait: Trait | None = None  # its own trait, since traits can be treated like functions
    # noinspection PyDefaultArgument
    def __init__(self, options: dict[FlexiPatt, opt_resolution] = {},
                 *fields: Field,
                 name: str = None,
                 fn_options: dict[FlexiPatt, opt_resolution] = {},
                 fn_fields: list[Field] = [],
                 uninitialized=False): ... #, own_trait: Trait = None): ...
    # def get_field(self, rec: Record, index: int): ...
    # def set_field(self, rec: Record, index: int, value: Record): ...
    def upsert_field(self, field: Field): ...
    # def add_own_option(self, pattern: FlexiPatt, resolution: opt_resolution = None) -> Option: ...
    # def select_by_value(self, value: tuple[Record, ...], ascend_env=True) -> Option | None: ...

class Table(Function):
    records: list[Record] | dict[Record, Record] | set[Record] | None
    traits: tuple[Trait, ...]  # the traits to be used by instances.  traits[0] is defined in the table body block
    catalog: OptionCatalog
    getters: dict[str, int | Function]
    setters: dict[str, int | Function]
    defaults: tuple[Function, ...]  # this is for instantiation of Records
    types: tuple[str, Pattern]  # the type of each field, in the same order as defaults
    trait: Trait  # property that points to the first trait in traits
    # noinspection PyDefaultArgument
    def __init__(self, *traits: Trait,
                 name: str = None,
                 fn_options: dict[FlexiPatt, opt_resolution] = {},
                 fn_fields: list[Field] = [],
                 uninitialized=False): ...
    def integrate_traits(self): ...
    def __getitem__(self, key: Record) -> Record | None: ...
    def __setitem__(self, key: Record, value: Record): ...
    def __contains__(self, item: Record): ...
    # def upsert_field(self, field: Field): ...
    def add_record(self, record: Record): ...

class ListTable(Table):
    records: list[Record]
    # def __init__(self, *traits: Trait, fields: list[Field], name: str = None): ...
    def __getitem__(self, key: PyValue[int]): ...

class MetaTable(ListTable): ...
class BootstrapTable(ListTable):
    def __init__(self, name: str): ...

class DictTable(Table):
    records: dict[Record, Record]
    key_field: int
    def __init__(self, key_field: int = 0, *field_tuple, **fields): ...

class SetTable(Table):
    records: set[Record]
    # def __init__(self, *fields, name=None): ...

class VirtTable(SetTable):
    records = None
    # def __init__(self, *fields, name=None): ...

# class Slice(Table):
#     parent: Table
#     def __init__(self, parent: Table): ...
#
# class PredicateSlice(Slice, VirtTable):
#     predicate: Function | PyFunction
#     def __init__(self, parent: Table, predicate: Function | PyFunction): ...
#
# class VirtSlice(Slice, VirtTable): ...
#
# class ListSlice(Slice, ListTable): ...
#
# class DictSlice(Slice, DictTable): ...
#
# class SetSlice(Slice, SetTable): ...

class Field(Record):
    name: str
    type: Matcher = None
    def __init__(self, name: str,
                 type: Matcher = None,
                 default: Function | None = py_value(None),
                 formula: Function = py_value(None)): ...

    # def get_data(self, rec: Record, idx: int): ...
    # def set_data(self, rec: Record, idx: int, value): ...

class Slot(Field):
    default: Function | None  # default should be a function with a single option with a single parameter: self
    def __init__(self, name: str, type: Matcher, default: Function = None): ...
    # def get_data(self, rec: Record, idx: int): ...
    # def set_data(self, rec: Record, idx: int, value): ...

class Formula(Field):
    formula: Function
    def __init__(self, name: str, type: Matcher, formula: Function): ...
    # def get_data(self, rec: Record, idx: int): ...

class Setter(Field):
    fn: Function
    def __init__(self, name: str, fn: Function): ...
    # def set_data(self, rec: Record, idx: int, value): ...

class Pattern(Record):
    def __init__(self): ...
    def match(self, arg: Record) -> None | dict[str, Record]: ...
    def match_and_bind(self, arg: Record) -> Record: ...
    def issubset(self, other: Pattern) -> bool: ...
    def match_score(self, arg: Record) -> bool | int | float: ...

class Matcher:
    rank: tuple[int, int, ...]  # for sorting
    def __init__(self, name: str = None, guard: Function | PyFunction = None, inverse=False): ...
    def match(self, arg: Record) -> None | dict[str, Record]: ...
    def issubset(self, other: Matcher) -> bool: ...
    def equivalent(self, other: Matcher) -> bool: ...
    def match_score(self, arg: Record) -> bool | float: ...
    def basic_score(self, arg) -> bool | float: ...

class TableMatcher(Matcher):
    table: Table
    def __init__(self, table: Table, name: str = None, guard: Function | PyFunction = None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class TraitMatcher(Matcher):
    trait: Trait
    def __init__(self, trait: Trait, name: str = None, guard: Function | PyFunction = None, inverse=False): ...

class ValueMatcher(Matcher):
    value: Record
    def __init__(self, value: Record, name: str = None, guard: Function | PyFunction = None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class ArgsMatcher(Matcher):
    params: ParamSet | None = None
    def __init__(self, *params: Parameter | ParamSet): ...

class FunctionSignatureMatcher(Matcher):
    pattern: ParamSet
    return_type: Matcher
    def __init__(self, pattern: ParamSet, return_type: Matcher, name=None, guard=None, inverse=False): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class KeyValueMatcher(Matcher):
    items: dict[Record, Pattern]
    def __init__(self, items: dict[Record, Pattern]): ...

class AnyMatcher(Matcher):
    def __eq__(self, other): ...
    def __hash__(self): ...

class EmptyMatcher(Matcher):
    rank = 3, 0
    def __eq__(self, other): ...
    def __hash__(self): ...

class IterMatcher(Matcher):
    # params: ParamSet
    def __init__(self, *params): ...

# def dot_fn(a: Record, b: Record, *, suppress_error=False) -> Record: ...
@overload
def dot_call_fn(rec: Record, name: str | PyValue[str], args: Args = None,
                *, safe_get=False,
                   swizzle: PyValue | bool,
                   safe_call: bool = False) -> Record | None: ...
@overload
def dot_call_fn(rec: Record, args: Args,
                *, safe_get=False,
                   swizzle: PyValue | bool = False,
                   safe_call: bool = False) -> Record | None: ...

class FieldMatcher(Matcher):
    ordered_fields: tuple
    fields: dict  # dict[str, Parameter]
    def __init__(self, ordered_fields: tuple[Pattern, ...], fields: dict = None, **kwargs: Parameter): ...
    def items(self): ...

class ExprMatcher(Matcher):
    expr: any  # Node
    rank = 2, 0
    def __init__(self, expr):
        self.expr = expr

    def basic_score(self, arg: Record) -> bool:
        return self.expr.evaluate().truthy

class LambdaMatcher(Matcher):
    """ this matcher is only used internally, users cannot create LambdaMatchers """
    fn: PyFunction
    def __init__(self, fn: PyFunction): ...

class NotMatcher(Matcher):
    def __init__(self, matcher: Matcher): ...

class BindingMatcher(Matcher):
    matcher: Matcher
    binding: str
    def __init__(self, matcher: Matcher, binding: str): ...


class IntersectionMatcher(Matcher):
    matchers: tuple[Matcher, ...]
    def __init__(self, *matchers: Matcher, binding: str = None, ): ...

class UnionMatcher(Matcher):
    matchers: tuple[Matcher, ...]
    def __init__(self, *matchers: Matcher, binding: str = None): ...

class Parameter(Pattern):
    pattern: Pattern
    binding: str | None
    quantifier: str  #  "+" | "*" | "?" | ""
    default: Option | None
    count: tuple[int, int | float]
    optional: bool
    required: bool
    multi: bool

    def __init__(self, pattern: Matcher | Pattern,
                 binding: str = None,
                 quantifier: str = "",
                 default: Record | Option = None): ...
    def issubset(self, other: Parameter) -> bool: ...
    def try_get_matchers(self) -> tuple[Matcher, ...] | list[Matcher]: ...
    def compare_quantifier(self, other: Parameter) -> int: ...
    def bytecode(self) -> list[Inst]: ...
    def match_score(self, value: Record) -> int | float: ...

class ParamSet(Pattern):
    """
    a sequence of zero or more parameters, together with their quantifiers
    as well as named parameters
    """
    # parameters: for matching iterables
    parameters: tuple[Parameter, ...]
    # named parameters of an Args record
    named_params: dict[str, Parameter]
    names_of_ordered_params: frozenset
    allow_arbitrary_kwargs: str | bool | None
    vm: list
    def __init__(self, *parameters: Parameter, named_params: dict[str, Parameter] = None): ...
    def to_args(self) -> Args | None: ...
    def issubset(self, other: ParamSet) -> bool: ...
    def __len__(self): ...
    def __getitem__(self, item): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class SpecialBindingParameter(Parameter): ...

class BindPropertyParam(SpecialBindingParameter):
    def __init__(self, rec: Record, field_name: str, pattern: Pattern = AnyMatcher(), default: Record = None): ...

class BindKeyParam(SpecialBindingParameter):
    def __init__(self, rec: Function, key: Args | ParamSet, pattern: Pattern = AnyMatcher(), default: Record = None): ...
    def match_and_bind(self, arg: Record | Closure) -> Record: ...

class VarPatt(SpecialBindingParameter):
    def __init__(self, name: str): ...

class LocalPatt(VarPatt): ...

class RegEx(Pattern, PyValue[str]):
    value: str
    flags: str
    def __init__(self, value: str, flags: str = ''): ...

def patternize(value: Record) -> Pattern: ...

class Args(Record):
    positional_arguments: list[Record] | tuple[Record]
    named_arguments: dict[str, Record]
    flags: set[str]
    def __init__(self, *args: Record, flags: set[str] = None, named_arguments: dict[str, Record] = None, **kwargs: Record): ...
    def __len__(self): ...
    def __getitem__(self, item: int | str) -> Record: ...
    def try_get(self, key: str | int) -> Record | None: ...
    def __iter__(self): ...
    def keys(self): ...
    def __add__(self, other: Args | tuple[Record] | set[str] | dict[str, Record]): ...
    def __radd__(self, other: Args | tuple[Record] | set[str] | dict[str, Record]): ...
    def __eq__(self, other): ...
    def dict(self) -> dict: ...
    def __hash__(self): ...
    def __repr__(self): ...


class Closure:
    block: Block | None
    fn: PyFunction | None # fn must accept one argument of type Args
    scope: Frame | None
    def __init__(self, block: Block | PyFunction): ...
    def execute(self, args: Args = None,
                caller: Record = None,
                bindings: dict[str, Record] = None,
                *,
                fn: Function = None,
                option: Option = None): ...

class Frame:
    vars: dict[str, Record]
    locals: dict[str, Record]
    scope: Frame
    args: Args
    caller: Record
    fn: Function
    return_value: Record = None
    def __init__(self, scope: Frame,
                 args: Args = None,
                 caller: Record = None,
                 bindings: dict[str, Record] = None,
                 fn: Function = None,
                 option: Option = None): ...
    def __getitem__(self, key: str) -> Record | None: ...
    def update(self, bindings: dict[str, Record]): ...
    def assign(self, name: str, value: Record): ...

class GlobalFrame(Frame):
    code_block = None
    scope = None
    args = None
    caller = None
    def __init__(self, bindings: dict[str, Record]): ...

opt_resolution = Record | Closure | PyFunction | None
class Option(Record):
    pattern: ParamSet
    resolution: opt_resolution
    value: Record
    block: Closure
    fn: PyFunction
    alias: Option
    dot_option: bool
    return_type: Matcher
    def __init__(self, pattern: FlexiPatt, resolution: opt_resolution = None): ...
    def is_null(self) -> bool: ...
    def not_null(self) -> bool: ...
    def nullify(self): ...
    # def assign(self, val_or_block: opt_resolution): ...
    def set_resolution(self, resolution) -> None: ...
    def get_resolution(self) -> opt_resolution: ...
    def resolve(self, args: Args | None,
                bindings: dict[str|int, Record] = None,
                caller: Record = None) \
            -> Record: ...

class Inst:
    opcode: str = 'tail'
    next = None  # Inst | None
    matcher: Matcher = None
    matchers: tuple[Matcher, ...] = ()
    i: int = None
    name: str = None
    binding: str = None
    default: Record = None
    branches = None
    Match = 'Match'
    MatchName = 'MatchName'
    MatchAll = 'MatchAll'
    Success = 'Success'
    Jump = 'Jump'
    Split = 'Split'
    Save = 'Save'
    Bind = 'Bind'
    BindRemaining = 'BindRemaining'
    BackRef = 'BackRef'
    Merge = 'Merge'
    def match(self, matcher: Matcher, binding: str = None, default: Record = None) -> Inst: ...
    def match_name(self, name: str, matcher: Matcher, next=None) -> Inst: ...
    def match_all(self, *matchers: Matcher, binding: str = None, default: Record = None) -> Inst: ...
    def success(self) -> Inst: ...
    def jump(self, next=None) -> Inst: ...
    def split(self, next, *branches) -> Inst: ...
    def save(self, name: str, next=None) -> Inst: ...
    def bind(self, name: str, default) -> Inst: ...
    def bind_remaining(self, name: str) -> Inst: ...
    def back_ref(self, i: int, next=None) -> Inst: ...
    def merge(self, step, count=2, next=None) -> Inst: ...
    def __iter__(self): ...
    def tree_repr(self) -> str: ...
    def str_node(self) -> str: ...
    def str_branches(self, seen=None, max_depth=10) -> str: ...
    def treer(self, idx: int, depth: int, seen: dict, acc: list, branch_sym='') -> str: ...


class ThreadList(deque):
    pass

def virtual_machine(prog: list[Inst],
                    args: tuple[Record, ...],
                    kwargs: dict[str, Record],
                    initial_bindings: dict[str, Record],
                    allow_arbitrary_kwargs: bool = False) \
        -> None | dict[str, Record]: ...